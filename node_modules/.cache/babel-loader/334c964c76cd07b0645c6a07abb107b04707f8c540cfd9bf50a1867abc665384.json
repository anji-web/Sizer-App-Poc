{"ast":null,"code":"var _jsxFileName = \"/Users/anjidananto/Projects/ARDemoApps/sizer-app-poc/src/components/Camera.jsx\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef, useState } from \"react\";\nimport { FilesetResolver, PoseLandmarker, DrawingUtils } from \"@mediapipe/tasks-vision\";\nimport Webcam from \"react-webcam\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst CameraComponent = ({\n  onMeasurement,\n  onPoseDetected,\n  isMeasuring,\n  userHeight\n}) => {\n  _s();\n  const webcamRef = useRef(null);\n  const canvasRef = useRef(null);\n  const [poseLandmarker, setPoseLandmarker] = useState(null);\n  const [isCorrectPose, setIsCorrectPose] = useState(false);\n  const [isLoading, setIsLoading] = useState(false);\n  const [hasSent, setHasSent] = useState(false);\n  const [calibrationFactor, setCalibrationFactor] = useState(null);\n  const measurementHistoryRef = useRef([]);\n  const cameraStyle = {\n    position: \"absolute\",\n    top: 0,\n    left: 0,\n    width: \"100%\",\n    height: \"100%\",\n    objectFit: \"cover\",\n    zIndex: 1\n  };\n  const canvasStyle = {\n    position: \"absolute\",\n    top: 0,\n    left: 0,\n    width: \"100%\",\n    height: \"100%\",\n    zIndex: 2,\n    pointerEvents: \"none\" // Memastikan canvas tidak mengganggu interaksi\n  };\n\n  // Calculate Euclidean distance between two points\n  const distance = (a, b) => Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));\n\n  // Calculate ellipse circumference using Ramanujan's approximation\n  const ellipseCircumference = (a, b) => {\n    const h = Math.pow(a - b, 2) / Math.pow(a + b, 2);\n    return Math.PI * (a + b) * (1 + 3 * h / (10 + Math.sqrt(4 - 3 * h)));\n  };\n\n  // Convert pixel measurements to centimeters using calibrated scale\n  const convertToCm = (pixelValue, scale) => {\n    return (pixelValue * scale).toFixed(1);\n  };\n\n  // Calculate scale factor based on user height and detected body proportions\n  const calculateScaleFactor = (landmarks, userHeightCm) => {\n    // Use the distance between shoulder and hip as reference (more stable than full height)\n    const shoulder = landmarks[11];\n    const hip = landmarks[23];\n    const torsoHeightPx = distance(shoulder, hip);\n\n    // Average torso-to-height ratio is about 0.3\n    const scale = userHeightCm * 0.3 / torsoHeightPx;\n    return scale;\n  };\n\n  // Calculate all body measurements with improved accuracy\n  const calculateMeasurements = landmarks => {\n    // Calculate scale factor for this frame\n    const scale = calibrationFactor || calculateScaleFactor(landmarks, userHeight);\n\n    // Shoulder points\n    const leftShoulder = landmarks[11];\n    const rightShoulder = landmarks[12];\n\n    // Hip points\n    const leftHip = landmarks[23];\n    const rightHip = landmarks[24];\n\n    // Midpoints\n    const midShoulder = {\n      x: (leftShoulder.x + rightShoulder.x) / 2,\n      y: (leftShoulder.y + rightShoulder.y) / 2\n    };\n    const midHip = {\n      x: (leftHip.x + rightHip.x) / 2,\n      y: (leftHip.y + rightHip.y) / 2\n    };\n\n    // 1. Chest Circumference (using ellipse formula)\n    const chestWidth = distance(leftShoulder, rightShoulder);\n    const chestDepth = distance(midShoulder, midHip) * 0.7;\n    const chestPixels = ellipseCircumference(chestWidth / 2, chestDepth / 2);\n\n    // 2. Waist Circumference\n    const waistWidth = distance(leftHip, rightHip);\n    const waistDepth = waistWidth * 0.8; // Approximation\n    const waistPixels = ellipseCircumference(waistWidth / 2, waistDepth / 2);\n\n    // 3. Hip Circumference\n    const hipWidth = distance(leftHip, rightHip) * 1.1;\n    const hipDepth = hipWidth * 0.85;\n    const hipPixels = ellipseCircumference(hipWidth / 2, hipDepth / 2);\n\n    // 4. Shoulder Width\n    const shoulderWidthPixels = distance(leftShoulder, rightShoulder);\n\n    // 5. Back Length\n    const backLengthPixels = distance(midShoulder, midHip);\n\n    // 6. Arm Length\n    const leftArmLengthPixels = distance(leftShoulder, landmarks[13]) +\n    // Shoulder to elbow\n    distance(landmarks[13], landmarks[15]); // Elbow to wrist\n\n    // 7. Bicep Circumference\n    const upperArmPixels = distance(landmarks[11], landmarks[13]) * 0.5;\n    const bicepPixels = upperArmPixels * Math.PI; // Approximation\n\n    // 8. Neck Circumference\n    const neckWidth = distance(landmarks[7], landmarks[8]);\n    const neckPixels = neckWidth * 2.4; // Approximation\n\n    return {\n      chest: convertToCm(chestPixels, scale),\n      waist: convertToCm(waistPixels, scale),\n      hips: convertToCm(hipPixels, scale),\n      shoulderWidth: convertToCm(shoulderWidthPixels, scale),\n      backLength: convertToCm(backLengthPixels, scale),\n      armLength: convertToCm(leftArmLengthPixels, scale),\n      bicep: convertToCm(bicepPixels, scale),\n      neck: convertToCm(neckPixels, scale)\n    };\n  };\n\n  // Enhanced pose validation\n  const validatePose = landmarks => {\n    if (!landmarks || landmarks.length < 32) return false;\n\n    // Required landmarks\n    const REQUIRED_POINTS = [0, 11, 12, 23, 24, 25, 26, 27, 28];\n    if (!REQUIRED_POINTS.every(i => landmarks[i])) return false;\n\n    // Check body alignment\n    const nose = landmarks[0];\n    const leftAnkle = landmarks[27];\n    const rightAnkle = landmarks[28];\n\n    // 1. Check if standing upright\n    const isUpright = nose.y < Math.min(leftAnkle.y, rightAnkle.y);\n\n    // 2. Check shoulder alignment (within 3% difference)\n    const shoulderLevelDiff = Math.abs(landmarks[11].y - landmarks[12].y);\n    const isShouldersLevel = shoulderLevelDiff < 0.03;\n\n    // 3. Check hip alignment\n    const hipLevelDiff = Math.abs(landmarks[23].y - landmarks[24].y);\n    const isHipsLevel = hipLevelDiff < 0.03;\n\n    // 4. Check if facing camera (shoulders wider than hips)\n    const shoulderWidth = distance(landmarks[11], landmarks[12]);\n    const hipWidth = distance(landmarks[23], landmarks[24]);\n    const isFacingCamera = shoulderWidth > hipWidth * 0.85;\n    const isValid = isUpright && isShouldersLevel && isHipsLevel && isFacingCamera;\n    setIsCorrectPose(isValid);\n\n    // Calculate calibration factor when in correct pose\n    if (isValid && !calibrationFactor) {\n      const factor = calculateScaleFactor(landmarks, userHeight);\n      setCalibrationFactor(factor);\n    }\n    return isValid;\n  };\n\n  // Smooth measurements over multiple frames\n  const smoothMeasurements = newMeasurements => {\n    measurementHistoryRef.current = [...measurementHistoryRef.current, newMeasurements].slice(-5);\n\n    // Calculate average of last 5 measurements\n    return Object.keys(newMeasurements).reduce((result, key) => {\n      const sum = measurementHistoryRef.current.reduce((total, measurement) => total + parseFloat(measurement[key]), 0);\n      result[key] = (sum / measurementHistoryRef.current.length).toFixed(1);\n      return result;\n    }, {});\n  };\n\n  // Load model\n  useEffect(() => {\n    const init = async () => {\n      try {\n        setIsLoading(true);\n        const vision = await FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm\");\n        const landmarker = await PoseLandmarker.createFromOptions(vision, {\n          baseOptions: {\n            modelAssetPath: \"https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task\",\n            delegate: \"GPU\"\n          },\n          runningMode: \"VIDEO\",\n          numPoses: 1\n        });\n        setPoseLandmarker(landmarker);\n      } catch (error) {\n        console.error(\"Error initializing pose landmarker:\", error);\n      } finally {\n        setIsLoading(false);\n      }\n    };\n    init();\n  }, []);\n\n  // Detection loop\n  useEffect(() => {\n    let animationFrame;\n    let frameCount = 0;\n    const runDetection = async () => {\n      if (!webcamRef.current || !poseLandmarker) return;\n      const video = webcamRef.current.video;\n      if (video.readyState !== 4) {\n        animationFrame = requestAnimationFrame(runDetection);\n        return;\n      }\n      const canvas = canvasRef.current;\n      const ctx = canvas.getContext(\"2d\");\n      canvas.width = video.videoWidth;\n      canvas.height = video.videoHeight;\n\n      // Throttle detection to every 3rd frame for performance\n      if (frameCount % 3 === 0) {\n        const result = poseLandmarker.detectForVideo(video, performance.now());\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        // ctx.drawImage(video, 0, 0, canvas.width, canvas.height);\n\n        if (result.landmarks.length > 0) {\n          const landmarks = result.landmarks[0];\n          onPoseDetected(landmarks);\n\n          // Draw landmarks\n          const drawingUtils = new DrawingUtils(ctx);\n          const KEYPOINTS = [0, 11, 12, 13, 14, 15, 16, 23, 24, 25, 26, 27, 28];\n          drawingUtils.drawLandmarks(landmarks.filter((_, i) => KEYPOINTS.includes(i)), {\n            color: isCorrectPose ? \"#00FF00\" : \"#FF0000\",\n            radius: 4\n          });\n\n          // Validate pose and take measurements\n          const isValid = validatePose(landmarks);\n          if (isValid && isMeasuring && !hasSent) {\n            const rawMeasurements = calculateMeasurements(landmarks);\n            const smoothed = smoothMeasurements(rawMeasurements);\n            if (measurementHistoryRef.current.length >= 3) {\n              // Wait for 3 good samples\n              console.log(\"Body Measurements:\", smoothed);\n              onMeasurement(smoothed);\n              setHasSent(true);\n            }\n          }\n        }\n      }\n      frameCount++;\n      animationFrame = requestAnimationFrame(runDetection);\n    };\n    animationFrame = requestAnimationFrame(runDetection);\n    return () => {\n      cancelAnimationFrame(animationFrame);\n    };\n  }, [poseLandmarker, isCorrectPose, isMeasuring, hasSent]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    style: {\n      position: \"relative\",\n      width: \"100%\",\n      height: \"100%\",\n      overflow: \"hidden\"\n    },\n    children: [/*#__PURE__*/_jsxDEV(Webcam, {\n      ref: webcamRef,\n      audio: false,\n      mirrored: true,\n      screenshotFormat: \"image/jpeg\",\n      videoConstraints: {\n        facingMode: \"user\",\n        width: 1280,\n        height: 720,\n        frameRate: 30\n      },\n      style: cameraStyle,\n      onUserMediaError: error => console.error(\"Webcam error:\", error)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 287,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      style: canvasStyle\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 303,\n      columnNumber: 7\n    }, this), isLoading && /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        position: \"absolute\",\n        top: 0,\n        left: 0,\n        right: 0,\n        bottom: 0,\n        display: \"flex\",\n        alignItems: \"center\",\n        justifyContent: \"center\",\n        backgroundColor: \"rgba(0,0,0,0.5)\",\n        zIndex: 3,\n        color: \"white\"\n      },\n      children: /*#__PURE__*/_jsxDEV(\"p\", {\n        children: \"Menyiapkan kamera dan model...\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 323,\n        columnNumber: 11\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 310,\n      columnNumber: 9\n    }, this), !isCorrectPose && !isLoading && /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        position: \"absolute\",\n        bottom: \"20px\",\n        left: \"50%\",\n        transform: \"translateX(-50%)\",\n        backgroundColor: \"rgba(0,0,0,0.7)\",\n        color: \"white\",\n        padding: \"10px 20px\",\n        borderRadius: \"5px\",\n        zIndex: 3,\n        textAlign: \"center\"\n      },\n      children: [/*#__PURE__*/_jsxDEV(\"p\", {\n        children: \"Berdiri tegak dengan kedua kaki terbuka selebar bahu\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 341,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: \"Pastikan seluruh tubuh terlihat dalam frame\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 342,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 329,\n      columnNumber: 9\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 285,\n    columnNumber: 5\n  }, this);\n};\n_s(CameraComponent, \"mLHu/vYcoiMYZ+E4oYneDh3JWSY=\");\n_c = CameraComponent;\nexport default CameraComponent;\nvar _c;\n$RefreshReg$(_c, \"CameraComponent\");","map":{"version":3,"names":["React","useEffect","useRef","useState","FilesetResolver","PoseLandmarker","DrawingUtils","Webcam","jsxDEV","_jsxDEV","CameraComponent","onMeasurement","onPoseDetected","isMeasuring","userHeight","_s","webcamRef","canvasRef","poseLandmarker","setPoseLandmarker","isCorrectPose","setIsCorrectPose","isLoading","setIsLoading","hasSent","setHasSent","calibrationFactor","setCalibrationFactor","measurementHistoryRef","cameraStyle","position","top","left","width","height","objectFit","zIndex","canvasStyle","pointerEvents","distance","a","b","Math","sqrt","pow","x","y","ellipseCircumference","h","PI","convertToCm","pixelValue","scale","toFixed","calculateScaleFactor","landmarks","userHeightCm","shoulder","hip","torsoHeightPx","calculateMeasurements","leftShoulder","rightShoulder","leftHip","rightHip","midShoulder","midHip","chestWidth","chestDepth","chestPixels","waistWidth","waistDepth","waistPixels","hipWidth","hipDepth","hipPixels","shoulderWidthPixels","backLengthPixels","leftArmLengthPixels","upperArmPixels","bicepPixels","neckWidth","neckPixels","chest","waist","hips","shoulderWidth","backLength","armLength","bicep","neck","validatePose","length","REQUIRED_POINTS","every","i","nose","leftAnkle","rightAnkle","isUpright","min","shoulderLevelDiff","abs","isShouldersLevel","hipLevelDiff","isHipsLevel","isFacingCamera","isValid","factor","smoothMeasurements","newMeasurements","current","slice","Object","keys","reduce","result","key","sum","total","measurement","parseFloat","init","vision","forVisionTasks","landmarker","createFromOptions","baseOptions","modelAssetPath","delegate","runningMode","numPoses","error","console","animationFrame","frameCount","runDetection","video","readyState","requestAnimationFrame","canvas","ctx","getContext","videoWidth","videoHeight","detectForVideo","performance","now","clearRect","drawingUtils","KEYPOINTS","drawLandmarks","filter","_","includes","color","radius","rawMeasurements","smoothed","log","cancelAnimationFrame","style","overflow","children","ref","audio","mirrored","screenshotFormat","videoConstraints","facingMode","frameRate","onUserMediaError","fileName","_jsxFileName","lineNumber","columnNumber","right","bottom","display","alignItems","justifyContent","backgroundColor","transform","padding","borderRadius","textAlign","_c","$RefreshReg$"],"sources":["/Users/anjidananto/Projects/ARDemoApps/sizer-app-poc/src/components/Camera.jsx"],"sourcesContent":["import React, { useEffect, useRef, useState } from \"react\";\nimport { FilesetResolver, PoseLandmarker, DrawingUtils } from \"@mediapipe/tasks-vision\";\nimport Webcam from \"react-webcam\";\n\nconst CameraComponent = ({ onMeasurement, onPoseDetected, isMeasuring, userHeight }) => {\n  const webcamRef = useRef(null);\n  const canvasRef = useRef(null);\n  const [poseLandmarker, setPoseLandmarker] = useState(null);\n  const [isCorrectPose, setIsCorrectPose] = useState(false);\n  const [isLoading, setIsLoading] = useState(false);\n  const [hasSent, setHasSent] = useState(false);\n  const [calibrationFactor, setCalibrationFactor] = useState(null);\n  const measurementHistoryRef = useRef([]);\n  const cameraStyle = {\n    position: \"absolute\",\n    top: 0,\n    left: 0,\n    width: \"100%\",\n    height: \"100%\",\n    objectFit: \"cover\",\n    zIndex: 1,\n  };\n\n  const canvasStyle = {\n    position: \"absolute\",\n    top: 0,\n    left: 0,\n    width: \"100%\",\n    height: \"100%\",\n    zIndex: 2,\n    pointerEvents: \"none\", // Memastikan canvas tidak mengganggu interaksi\n  };\n\n  // Calculate Euclidean distance between two points\n  const distance = (a, b) => \n    Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));\n\n  // Calculate ellipse circumference using Ramanujan's approximation\n  const ellipseCircumference = (a, b) => {\n    const h = Math.pow((a - b), 2) / Math.pow((a + b), 2);\n    return Math.PI * (a + b) * (1 + (3 * h) / (10 + Math.sqrt(4 - 3 * h)));\n  };\n\n  // Convert pixel measurements to centimeters using calibrated scale\n  const convertToCm = (pixelValue, scale) => {\n    return (pixelValue * scale).toFixed(1);\n  };\n\n  // Calculate scale factor based on user height and detected body proportions\n  const calculateScaleFactor = (landmarks, userHeightCm) => {\n    // Use the distance between shoulder and hip as reference (more stable than full height)\n    const shoulder = landmarks[11];\n    const hip = landmarks[23];\n    const torsoHeightPx = distance(shoulder, hip);\n    \n    // Average torso-to-height ratio is about 0.3\n    const scale = userHeightCm * 0.3 / torsoHeightPx;\n    return scale;\n  };\n\n  // Calculate all body measurements with improved accuracy\n  const calculateMeasurements = (landmarks) => {\n    // Calculate scale factor for this frame\n    const scale = calibrationFactor || calculateScaleFactor(landmarks, userHeight);\n    \n    // Shoulder points\n    const leftShoulder = landmarks[11];\n    const rightShoulder = landmarks[12];\n    \n    // Hip points\n    const leftHip = landmarks[23];\n    const rightHip = landmarks[24];\n    \n    // Midpoints\n    const midShoulder = {\n      x: (leftShoulder.x + rightShoulder.x) / 2,\n      y: (leftShoulder.y + rightShoulder.y) / 2\n    };\n    \n    const midHip = {\n      x: (leftHip.x + rightHip.x) / 2,\n      y: (leftHip.y + rightHip.y) / 2\n    };\n\n    // 1. Chest Circumference (using ellipse formula)\n    const chestWidth = distance(leftShoulder, rightShoulder);\n    const chestDepth = distance(midShoulder, midHip) * 0.7;\n    const chestPixels = ellipseCircumference(chestWidth/2, chestDepth/2);\n    \n    // 2. Waist Circumference\n    const waistWidth = distance(leftHip, rightHip);\n    const waistDepth = waistWidth * 0.8; // Approximation\n    const waistPixels = ellipseCircumference(waistWidth/2, waistDepth/2);\n    \n    // 3. Hip Circumference\n    const hipWidth = distance(leftHip, rightHip) * 1.1;\n    const hipDepth = hipWidth * 0.85;\n    const hipPixels = ellipseCircumference(hipWidth/2, hipDepth/2);\n    \n    // 4. Shoulder Width\n    const shoulderWidthPixels = distance(leftShoulder, rightShoulder);\n    \n    // 5. Back Length\n    const backLengthPixels = distance(midShoulder, midHip);\n    \n    // 6. Arm Length\n    const leftArmLengthPixels = \n      distance(leftShoulder, landmarks[13]) + // Shoulder to elbow\n      distance(landmarks[13], landmarks[15]); // Elbow to wrist\n    \n    // 7. Bicep Circumference\n    const upperArmPixels = distance(landmarks[11], landmarks[13]) * 0.5;\n    const bicepPixels = upperArmPixels * Math.PI; // Approximation\n    \n    // 8. Neck Circumference\n    const neckWidth = distance(landmarks[7], landmarks[8]);\n    const neckPixels = neckWidth * 2.4; // Approximation\n    \n    return {\n      chest: convertToCm(chestPixels, scale),\n      waist: convertToCm(waistPixels, scale),\n      hips: convertToCm(hipPixels, scale),\n      shoulderWidth: convertToCm(shoulderWidthPixels, scale),\n      backLength: convertToCm(backLengthPixels, scale),\n      armLength: convertToCm(leftArmLengthPixels, scale),\n      bicep: convertToCm(bicepPixels, scale),\n      neck: convertToCm(neckPixels, scale)\n    };\n  };\n\n  // Enhanced pose validation\n  const validatePose = (landmarks) => {\n    if (!landmarks || landmarks.length < 32) return false;\n    \n    // Required landmarks\n    const REQUIRED_POINTS = [0, 11, 12, 23, 24, 25, 26, 27, 28];\n    if (!REQUIRED_POINTS.every(i => landmarks[i])) return false;\n    \n    // Check body alignment\n    const nose = landmarks[0];\n    const leftAnkle = landmarks[27];\n    const rightAnkle = landmarks[28];\n    \n    // 1. Check if standing upright\n    const isUpright = nose.y < Math.min(leftAnkle.y, rightAnkle.y);\n    \n    // 2. Check shoulder alignment (within 3% difference)\n    const shoulderLevelDiff = Math.abs(landmarks[11].y - landmarks[12].y);\n    const isShouldersLevel = shoulderLevelDiff < 0.03;\n    \n    // 3. Check hip alignment\n    const hipLevelDiff = Math.abs(landmarks[23].y - landmarks[24].y);\n    const isHipsLevel = hipLevelDiff < 0.03;\n    \n    // 4. Check if facing camera (shoulders wider than hips)\n    const shoulderWidth = distance(landmarks[11], landmarks[12]);\n    const hipWidth = distance(landmarks[23], landmarks[24]);\n    const isFacingCamera = shoulderWidth > hipWidth * 0.85;\n    \n    const isValid = isUpright && isShouldersLevel && isHipsLevel && isFacingCamera;\n    setIsCorrectPose(isValid);\n    \n    // Calculate calibration factor when in correct pose\n    if (isValid && !calibrationFactor) {\n      const factor = calculateScaleFactor(landmarks, userHeight);\n      setCalibrationFactor(factor);\n    }\n    \n    return isValid;\n  };\n\n  // Smooth measurements over multiple frames\n  const smoothMeasurements = (newMeasurements) => {\n    measurementHistoryRef.current = [...measurementHistoryRef.current, newMeasurements].slice(-5);\n    \n    // Calculate average of last 5 measurements\n    return Object.keys(newMeasurements).reduce((result, key) => {\n      const sum = measurementHistoryRef.current.reduce(\n        (total, measurement) => total + parseFloat(measurement[key]), 0\n      );\n      result[key] = (sum / measurementHistoryRef.current.length).toFixed(1);\n      return result;\n    }, {});\n  };\n\n  // Load model\n  useEffect(() => {\n    const init = async () => {\n      try {\n        setIsLoading(true);\n        const vision = await FilesetResolver.forVisionTasks(\n          \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm\"\n        );\n\n        const landmarker = await PoseLandmarker.createFromOptions(vision, {\n          baseOptions: {\n            modelAssetPath:\n              \"https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task\",\n            delegate: \"GPU\",\n          },\n          runningMode: \"VIDEO\",\n          numPoses: 1,\n        });\n\n        setPoseLandmarker(landmarker);\n      } catch (error) {\n        console.error(\"Error initializing pose landmarker:\", error);\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    init();\n  }, []);\n\n  // Detection loop\n  useEffect(() => {\n    let animationFrame;\n    let frameCount = 0;\n\n    const runDetection = async () => {\n      if (!webcamRef.current || !poseLandmarker) return;\n\n      const video = webcamRef.current.video;\n      if (video.readyState !== 4) {\n        animationFrame = requestAnimationFrame(runDetection);\n        return;\n      }\n\n      const canvas = canvasRef.current;\n      const ctx = canvas.getContext(\"2d\");\n      canvas.width = video.videoWidth;\n      canvas.height = video.videoHeight;\n\n      // Throttle detection to every 3rd frame for performance\n      if (frameCount % 3 === 0) {\n        const result = poseLandmarker.detectForVideo(video, performance.now());\n        \n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        // ctx.drawImage(video, 0, 0, canvas.width, canvas.height);\n\n        if (result.landmarks.length > 0) {\n          const landmarks = result.landmarks[0];\n          onPoseDetected(landmarks);\n\n          // Draw landmarks\n          const drawingUtils = new DrawingUtils(ctx);\n          const KEYPOINTS = [0, 11, 12, 13, 14, 15, 16, 23, 24, 25, 26, 27, 28];\n          \n          drawingUtils.drawLandmarks(\n            landmarks.filter((_, i) => KEYPOINTS.includes(i)),\n            {\n              color: isCorrectPose ? \"#00FF00\" : \"#FF0000\",\n              radius: 4,\n            }\n          );\n\n          // Validate pose and take measurements\n          const isValid = validatePose(landmarks);\n          if (isValid && isMeasuring && !hasSent) {\n            const rawMeasurements = calculateMeasurements(landmarks);\n            const smoothed = smoothMeasurements(rawMeasurements);\n            \n            if (measurementHistoryRef.current.length >= 3) { // Wait for 3 good samples\n              console.log(\"Body Measurements:\", smoothed);\n              onMeasurement(smoothed);\n              setHasSent(true);\n            }\n          }\n        }\n      }\n      \n      frameCount++;\n      animationFrame = requestAnimationFrame(runDetection);\n    };\n\n    animationFrame = requestAnimationFrame(runDetection);\n\n    return () => {\n      cancelAnimationFrame(animationFrame);\n    };\n  }, [poseLandmarker, isCorrectPose, isMeasuring, hasSent]);\n\n  return (\n    <div style={{ position: \"relative\", width: \"100%\", height: \"100%\", overflow: \"hidden\" }}>\n      {/* Webcam dengan mirroring */}\n      <Webcam\n        ref={webcamRef}\n        audio={false}\n        mirrored\n        screenshotFormat=\"image/jpeg\"\n        videoConstraints={{\n          facingMode: \"user\",\n          width: 1280,\n          height: 720,\n          frameRate: 30\n        }}\n        style={cameraStyle}\n        onUserMediaError={(error) => console.error(\"Webcam error:\", error)}\n      />\n      \n      {/* Canvas untuk menggambar landmark */}\n      <canvas\n        ref={canvasRef}\n        style={canvasStyle}\n      />\n      \n      {/* Status loading */}\n      {isLoading && (\n        <div style={{\n          position: \"absolute\",\n          top: 0,\n          left: 0,\n          right: 0,\n          bottom: 0,\n          display: \"flex\",\n          alignItems: \"center\",\n          justifyContent: \"center\",\n          backgroundColor: \"rgba(0,0,0,0.5)\",\n          zIndex: 3,\n          color: \"white\"\n        }}>\n          <p>Menyiapkan kamera dan model...</p>\n        </div>\n      )}\n      \n      {/* Panduan pose */}\n      {!isCorrectPose && !isLoading && (\n        <div style={{\n          position: \"absolute\",\n          bottom: \"20px\",\n          left: \"50%\",\n          transform: \"translateX(-50%)\",\n          backgroundColor: \"rgba(0,0,0,0.7)\",\n          color: \"white\",\n          padding: \"10px 20px\",\n          borderRadius: \"5px\",\n          zIndex: 3,\n          textAlign: \"center\"\n        }}>\n          <p>Berdiri tegak dengan kedua kaki terbuka selebar bahu</p>\n          <p>Pastikan seluruh tubuh terlihat dalam frame</p>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default CameraComponent;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}